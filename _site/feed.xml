<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Yan Blog</title>
    <description>代码编织梦想，程序创造未来</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 08 Sep 2019 19:54:46 +0800</pubDate>
    <lastBuildDate>Sun, 08 Sep 2019 19:54:46 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>python编码问题</title>
        <description>&lt;h3 id=&quot;常用编码&quot;&gt;常用编码&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;ASCII编码：   &lt;br /&gt;
 8个比特作为一个字节（byte）&lt;/li&gt;
  &lt;li&gt;Unicode编码： &lt;br /&gt;
 常用的是2个字节表示一个字符，所以用Unicode编码比ASCII编码要多一倍的存储空间。&lt;/li&gt;
  &lt;li&gt;UTF-8编码（可变长编码）： &lt;br /&gt;
 UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编译成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字符。&lt;/li&gt;
  &lt;li&gt;GB2312简体中文编码： &lt;br /&gt;
 一个汉字占用2个字节，该编码遇到繁体中文、日文、韩文时，这些文字内容无法被正确编码。&lt;/li&gt;
  &lt;li&gt;BIG5繁体中文编码： &lt;br /&gt;
 在台湾地区使用。&lt;/li&gt;
  &lt;li&gt;GBK编码： &lt;br /&gt;
 支持简体及繁体中文，但对他国非拉丁字母还有问题。可以表示21886个字符。&lt;/li&gt;
  &lt;li&gt;GB18030字符集： &lt;br /&gt;
 解决了中文、日文、朝鲜语系的编码，兼容GBK，可以表示27484个文字。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;ep:
字符      ASCII           Unicode                    UTF-8
 A      01000001     00000000 01000001             01000001
 中        X         01001110 00101101     11100100 10111000 10101101
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;h3 id=&quot;编码原理&quot;&gt;编码原理&lt;/h3&gt;
    &lt;p&gt;  在计算机内存中，统一使用&lt;strong&gt;Unicode&lt;/strong&gt;编码，当需要保存到硬盘或需要传输的时候，就转换为UTF-8编码。 &lt;br /&gt;
以记事本为例：&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;                           Unicode编码
                 ↗                           |
                 |                           ↘
             读取，转换为Unicode         保存，转换为UTF-8编码
                 ↗                           |
                 |                           |
               txt文件                     txt文件
                 ↗                           |
                 |                           ↘
                             UTF-8编码
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;h3 id=&quot;编码介绍&quot;&gt;编码介绍&lt;/h3&gt;
    &lt;p&gt;1.ANSI–&amp;gt; ASCII 用于保存英文文字 &lt;br /&gt;
  一个字节，共有8个比特位，有256个字符，其中ASCII使用了127个，用于表示所有的空格、标点符号、数字、大小写字母。 &lt;br /&gt;
  采用127号之后的空位来表示这些新的字母、符号，加入了很多画表格时需要用下到的横线、竖线、交叉等形状，一直把序号编到了 最后一个状态255。从128到255这一页的字符集被称”扩展字符集。 &lt;br /&gt;
2.GB2312（扩展了ANSI） &lt;br /&gt;
  用两个字节表示，一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到 0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了 &lt;br /&gt;
3.GBK（扩展了GB2312） &lt;br /&gt;
  GBK不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字符集里的内容。结果扩展之后的编码方案被称为 GBK 标准，GBK 包括了 GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。后来少数民族也要用电脑了，我们再扩展，又加了几千个新的少数民族的字，GBK 扩成了 GB18030。 &lt;br /&gt;
4.Unicode(统一规范) &lt;br /&gt;
  一律使用2个字节，即16位统一表示所有的字符。 &lt;br /&gt;
Unicode与UTF-8编码转换规则&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Unicode               --&amp;gt;            UTF-8
0000 – 007F                            0xxxxxxx                    1个字节
0080 – 07FF                       110xxxxx 10xxxxxx                2个字节
0800 – FFFF                    1110xxxx 10xxxxxx 10xxxxxx          3个字节
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;举例说明该转换规则： &lt;br /&gt;
  汉字‘汉’的Unicode编码对应是6C49，在6C49位于0800-FFFF之间，所以要用3字节模板：1110xxxx 10xxxxxx 10xxxxxx。将6C49写成二进制是：0110 1100 0100 1001，将这个比特流按三字节模板的分段方法分为0110 110001 001001，依次代替模板中的x，得到：1110-0110 10-110001 10-001001，即E6 B1 89，这就是其UTF8的编码。&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;                            6C49
                       0800&amp;lt;6C49&amp;lt;FFFF
             模版：1110xxxx 10xxxxxx 10xxxxxx
                            6C49         Unicode编码
                             |
               0110    1100   0100    1001
                             |
                 0110    110001     001001
                             |  带入模版，替换X
             11100110    10110001    10001001
                             |
           1110    0110   1011   0001   1000   1001
                             |
                     E6     B1     89      UTF-8编码
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;h3 id=&quot;python编码&quot;&gt;python编码&lt;/h3&gt;
    &lt;p&gt;  字符串在Python内部的表示是&lt;strong&gt;unicode&lt;/strong&gt;编码，因此，在做编码转换时，通常需要以unicode作为中间编码，即现将其他编码的字符串解码（decode）成unicode，再从unicode编码（encode）成另外一种编码。原有编码–&amp;gt;内部编码Unicode–&amp;gt;目标编码  &lt;br /&gt;
  &lt;strong&gt;decode&lt;/strong&gt;的作用是将其他编码的字符串转换成unicode编码，如str1.decode(‘gb2312’)，表示将gb2312编码的字符串转换成unicode编码。 &lt;br /&gt;
  &lt;strong&gt;encode&lt;/strong&gt;的作用是将unicode编码转换成其他编码的字符串，如str2.encode(‘gb2312’)，表示将unicode编码的字符串转换成gb2312编码。 &lt;br /&gt;
over&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 07 Sep 2019 02:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/09/07/python%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/09/07/python%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</guid>
        
        <category>学习</category>
        
        <category>python</category>
        
        
      </item>
    
      <item>
        <title>centos7下常用开发环境的搭建</title>
        <description>&lt;p&gt;  在安装开发环境之前，建议用户首先进行linux中已安装软件包的更新，执行下面命令进行更新（必须联网），更新时间可能会比较久，需要等待一段时间。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;yum update
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;cc环境&quot;&gt;C、C++环境&lt;/h4&gt;
&lt;p&gt;  服务器中安装的很多工具包都需要c语言和c++语言的环境支持，所以在服务器上部署其他服务之前首先进行c语言和c++语言的环境安装。&lt;br /&gt;
C环境：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;yum -y install gcc  
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;C++环境：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;yum -y install gcc-c++ libstdc++-devel
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;python环境&quot;&gt;python环境&lt;/h4&gt;
&lt;p&gt;  centos系统都预装有python2.7环境，所以在这里就不进行介绍python环境的安装，如果需要的话请参考python官网：https://www.python.org/downloads/。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;1. 安装epel扩展源   
yum -y install epel-release
2. 更新成功之后，安装python包管理工具pip   
yum -y install python-pip
3. 安装后清理cache   
yum clean all
4. 安装包失败可执行如下更新命令（更新pip工具）   
pip install --upgrade pip  
5. 安装python开发环境   
yum -y install python-devel  
yum -y install libevent-devel  
yum -y install gevent
yum -y install groupinstall 'development tools'  
6. 升级setuptools   
pip install --upgrade setuptools
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;  python常用的web开发框架Django及扩展包安装&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;1. 安装Django   
pip install django  
2. 安装django跨域使用扩展包corsheaders   
pip install django-cors-middleware  
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;java环境&quot;&gt;java环境&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;下载jdk安装包，下载地址：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html&lt;br /&gt;
或者在服务器上执行下面命令：
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;wget http://download.oracle.com/otn-pub/java/jdk/8u171-b11/512cd62ec5174c3487ac17c61aaa89e8/jdk-8u171-linux-x64.tar.gz?AuthParam=1531155951_4e06a4d17c6c1dbfb8440352e19dd2ae
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;该下载地址已失效 请自行在官网复制下载地址&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;下载好jdk-8u171-linux-x64.tar.gz安装包后，将安装包放在centos服务器中，&lt;/li&gt;
  &lt;li&gt;在服务器上创建安装目录 &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;mkdir /usr/local/java/&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;将安装包解压至安装目录 &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;tar -zxvf jdk-8u171-linux-x64.tar.gz -C /usr/local/java/&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;设置环境变量，打开文件/etc/profile，在文件末行插入下面信息后保存。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;export JAVA_HOME=/usr/local/java/jdk1.8.0_171
export JRE_HOME=${JAVA_HOME}/jre
export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib
export PATH=${JAVA_HOME}/bin:$PATH
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;执行下面命令使配置生效 &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;source /etc/profile&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;添加软链接 &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;ln -s /usr/local/java/jdk1.8.0_171/bin/java /usr/bin/java&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;检查是否安装成功 &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;java -version&lt;/code&gt;
    &lt;h4 id=&quot;docker环境&quot;&gt;docker环境&lt;/h4&gt;
    &lt;p&gt;1.安装docker &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;yum install docker&lt;/code&gt; &lt;br /&gt;
2.设置系统启动自动加载 &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;service docker start&lt;/code&gt; &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;chkconfig docker on&lt;/code&gt; &lt;br /&gt;
3.docker容器中文编码解决方案&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;1.
vi /etc/profile
export LANG = en_US.UTF-8
用该方法设置之后，每次启动容器之后都要执行一次source /etc/profile命令使配置生效。

2.
vi /root/.bashrc
export LANG = en_US.UTF-8
用该方法设置之后，不需要在容器启动后执行配置激活命令。
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;4.清理docker容器日志 &lt;br /&gt;
(1) &lt;code class=&quot;highlighter-rouge&quot;&gt;docker inspect 容器id或容器名&lt;/code&gt;  &lt;br /&gt;
(2)找到log文件所在的位置，一般为/var/log/—-/log-json.log &lt;br /&gt;
(3)执行命令清理日志： &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;cat /dev/null &amp;gt; /var/log/----/log-json.log&lt;/code&gt; &lt;br /&gt;
over&lt;/p&gt;
</description>
        <pubDate>Thu, 05 Sep 2019 04:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/09/05/centos7%E4%B8%8B%E5%B8%B8%E7%94%A8%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/09/05/centos7%E4%B8%8B%E5%B8%B8%E7%94%A8%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/</guid>
        
        <category>学习</category>
        
        <category>centos</category>
        
        <category>python</category>
        
        
      </item>
    
      <item>
        <title>docker存储管理</title>
        <description>&lt;h4 id=&quot;docker-volume形态&quot;&gt;Docker volume形态&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;volume介绍&lt;br /&gt;
  Docker 采用 AFUS 分层文件系统时，文件系统的改动都是发生在最上面的容器层，在容器的生命周期内，它是持续的，包括容器在被停止后。但是，当容器被删除后，该数据层也随之被删除了。因此，Docker 采用 volume （卷）的形式来向容器提供持久化存储.Docker volume 有如下几种形态：&lt;br /&gt;
1.1 默认，即无Docker volume&lt;br /&gt;
  默认情况下，容器不使用任何 volume，此时，容器的数据被保存在容器之内，它只在容器的生命周期内存在，会随着容器的被删除而被删除。当然，也可以使用 docker commit 命令将它持久化为一个新的镜像。&lt;br /&gt;
1.2 Data volume （数据卷） &lt;br /&gt;
  一个 data volume 是容器中绕过 Union 文件系统的一个特定的目录。它被设计用来保存数据，而不管容器的生命周期。因此，当你删除一个容器时，Docker 肯定不会自动地删除一个volume。&lt;br /&gt;
（1）使用 “-v 容器内目录” 形式&lt;br /&gt;
  &lt;code class=&quot;highlighter-rouge&quot;&gt;docker run -d -P --name web -v /webapp training/webapp python app.py&lt;/code&gt;&lt;br /&gt;
使用 docker inspect 命令可以看出，Docker 将本地一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;_data&lt;/code&gt; 目录 mount 为容器内的 webapp 目录了：
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&quot;Mounts&quot;: [
         {
             &quot;Name&quot;: &quot;f143b7f379fb6d012a08656fc950bf6df4bf5a5b90c72f310644aa997620122b&quot;,
             &quot;Source&quot;: &quot;/var/lib/docker/volumes/f143b7f379fb6d012a08656fc950bf6df4bf5a5b90c72f310644aa997620122b/_data&quot;,
             &quot;Destination&quot;: &quot;/webapp&quot;,
             &quot;Driver&quot;: &quot;local&quot;,
             &quot;Mode&quot;: &quot;&quot;,
             &quot;RW&quot;: true,
             &quot;Propagation&quot;: &quot;&quot;
         }
     ],  
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;其实，在 web 容器被删除后，&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/lib/docker/volumes/f143b7f379fb6d012a08656fc950bf6df4bf5a5b90c72f310644aa997620122b/_data&lt;/code&gt;目录及其中的内容都还会保留下来，但是，新启动的容器无法再使用这个目录，也就是说，已有的数据不能自动地被重复使用了。&lt;br /&gt;
（2）使用 -v 来挂载一个主机上的目录到容器的目录&lt;br /&gt;
  &lt;code class=&quot;highlighter-rouge&quot;&gt;docker run -d -P --name web2 -v /src/webapp:/webapp training/webapp python app.py&lt;/code&gt;&lt;br /&gt;
主机上的目录可以是一个本地目录，也可以在一个 NFS share 内，或者在一个已经格式化好了的块设备上。其实这种形式和第一种没有本质的区别，容器内对 /webapp 的操作都会反映到主机上的 /src/webapp 目录内。只是，重新启动容器时，可以再次使用同样的方式来将 /src/webapp 目录挂载到新的容器内，这样就可以实现数据持久化的目标。&lt;br /&gt;
（3）使用 -v 来挂载主机上的一个文件到容器内的一个文件&lt;br /&gt;
  &lt;code class=&quot;highlighter-rouge&quot;&gt;docker run --rm -it -v ~/.bash_history:/root/.bash_history ubuntu /bin/bash&lt;/code&gt;&lt;br /&gt;
1.3 data container（数据卷容器）&lt;br /&gt;
  如果要在容器之间共享数据，最好是使用 data container。这种 container 中不会跑应用，而只是挂载一个卷。&lt;br /&gt;
创建一个 data container：&lt;br /&gt;
  &lt;code class=&quot;highlighter-rouge&quot;&gt;docker create -v /dbdata --name dbstore training/webapp  /bin/true&lt;/code&gt;&lt;br /&gt;
启动一个 app container：&lt;br /&gt;
  &lt;code class=&quot;highlighter-rouge&quot;&gt;docker run -d -P --name web3 --volumes-from dbstore training/webapp python app.py&lt;/code&gt;&lt;br /&gt;
其实，对 web3 这个容器来说，volume 的本质没变，它只是将 dbstore 容器的 /dbdata 目录映射的主机上的目录映射到自身的 /dbdata 目录。&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&quot;Mounts&quot;: [
         {
             &quot;Name&quot;: &quot;5341c03f3b94f13f4c86d88ccb0f3b63487adf30dea7ae6b2d06e947235e7330&quot;,
             &quot;Source&quot;: &quot;/var/lib/docker/volumes/5341c03f3b94f13f4c86d88ccb0f3b63487adf30dea7ae6b2d06e947235e7330/_data&quot;,
             &quot;Destination&quot;: &quot;/dbdata&quot;,
             &quot;Driver&quot;: &quot;local&quot;,
             &quot;Mode&quot;: &quot;&quot;,
             &quot;RW&quot;: true,
             &quot;Propagation&quot;: &quot;&quot;
         }
     ],
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Tue, 19 Mar 2019 05:30:00 +0800</pubDate>
        <link>http://localhost:4000/2019/03/19/docker%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/03/19/docker%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/</guid>
        
        <category>学习</category>
        
        <category>docker</category>
        
        
      </item>
    
      <item>
        <title>docker容器可视化管理</title>
        <description>&lt;h4 id=&quot;docker-ui&quot;&gt;docker UI&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;优点：&lt;br /&gt;
  支持容器批量操作&lt;br /&gt;
  支持镜像管理&lt;/li&gt;
  &lt;li&gt;缺点：&lt;br /&gt;
  不支持多主机&lt;/li&gt;
  &lt;li&gt;部署：&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;docker pull uifd/ui-for-docker&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;docker run -it -d --name docker-web -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock docker.io/uifd/ui-for-docker&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;docker ps&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;访问：&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;192.168.177.11:9000&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;shipyard&quot;&gt;shipyard&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;介绍
shipyard是在docker swarm实现对容器、镜像、集群、仓库、节点进行管理的web系统。&lt;br /&gt;
shipyard包含以下容器及启动顺序：&lt;br /&gt;
（1）RethinkDB  作为数据库保存用户等信息&lt;br /&gt;
（2）Discovery  一个外部的密码值存储容器&lt;br /&gt;
（3）shipyard_certs  证书管理容器，实现证书验证功能&lt;br /&gt;
（4）proxy  使用TLS转发请求从TCP到docker监听的socket&lt;br /&gt;
（5）swarm manager  swarm管理器&lt;br /&gt;
（6）swarm agent swarm代理，运行在每个节点上&lt;br /&gt;
（7）controller  shipyard控制器，Remote API和web的实现。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;部署&lt;br /&gt;
脚本：shipyard-deploy&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;chmod 755 shipyard-deploy
sh shipyard-deploy   此时会创建以上七个容器，在浏览器访问8080端口即可看到shipyard登陆界面，登录用户名是admin，密码是shipyard
修改web访问端口：
cat shipyard-deploy | grep 8080
sed -i 's|8080|80|g' shipyard-deploy
重新部署
sh shipyard-deploy
删除shipyard环境
cat shipyard-delpoy | ACTION = remove bash
添加其他节点主机，在节点主机上操作
cat shipyard-deploy | ACTION = node DISCOVERY = etcd://192.168.177.11:4001 bash
删除节点机
cat shipyard-deploy | ACTION = remove bash -s
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;portainer&quot;&gt;portainer&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;下载镜像&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;docker pull portainer/portainer&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;单机运行&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;docker run -d -p 9000:9000 --restart = always -v /var/run/docker.sock:/var/run/docker.sock --name portainer-test portainer/portainer&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;集群运行&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;docker run -d -p 9000:9000 --restart = always --name portainer-test portainer/portainer&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 22 Feb 2019 17:30:00 +0800</pubDate>
        <link>http://localhost:4000/2019/02/22/docker%E5%AE%B9%E5%99%A8%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AE%A1%E7%90%86/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/02/22/docker%E5%AE%B9%E5%99%A8%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AE%A1%E7%90%86/</guid>
        
        <category>学习</category>
        
        <category>docker</category>
        
        
      </item>
    
      <item>
        <title>centos7下service(systemctl)的配置</title>
        <description>&lt;h4 id=&quot;service介绍&quot;&gt;service介绍&lt;/h4&gt;
&lt;p&gt;  service命令用于对系统服务进行管理，比如启动（start）、停止（stop）、重启（restart）、查看状态（status）等。
在centos7之前，系统启动服务使用&lt;code class=&quot;highlighter-rouge&quot;&gt;service https start&lt;/code&gt;的方式启动，此时其实是启动了存放在/etc/init.d目录下的脚本，在centos7中，服务管理修改了规则，centos7集成了RHEL 7的新的特性，例如强大的systemctl，而systemctl的使用也使得以往系统服务的/etc/init.d的启动脚本的方式就此改变，也大幅提高了系统服务的运行效率。但服务的配置和以往也发生了极大的不同，说实在的，变的简单而易用了许多。&lt;/p&gt;
&lt;h4 id=&quot;service配置&quot;&gt;service配置&lt;/h4&gt;
&lt;p&gt;  centos7的服务配置文件默认位置在/usr/lib/systemd目录下，有系统和用户之分，需要开机不登录就能运行的程序，在系统服务里，即/usr/lib/systemd/system目录下。&lt;br /&gt;
  每一个服务均以.service结尾，文件分为三部分，[Unit], [Service]和[Install]，完成脚本后，以754权限保存在以上目录。&lt;br /&gt;
  以下为MongoDB集群的一个分片shard配置的服务示例mongo_shard1.service:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;[Unit]
Description = mongodb service:shard1 Primary
After = syslog.target  network.target

[Service]
Type = forking
ExecStart = /usr/bin/mongod -f /data/config/primary.conf
ExecStop = /bin/kill -2 $MAINPID
KillMode = process
Restart = on-failure
User = root
Group = root

[Install]
WantedBy = multi-user.target
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;service启动&quot;&gt;service启动&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;启动&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;systemctl start mongo_shard1&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;设置开启自启&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;systemctl enable mongo_shard1&lt;/code&gt;&lt;br /&gt;
&lt;img src=&quot;../../../../img/404-bg.jpg&quot; style=&quot;width:50%&quot; /&gt;
&lt;img src=&quot;../../../../img/404-bg.jpg&quot; alt=&quot;hello&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 22 Feb 2019 16:30:00 +0800</pubDate>
        <link>http://localhost:4000/2019/02/22/centos7%E4%B8%8Bservice(systemctl)%E7%9A%84%E9%85%8D%E7%BD%AE/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/02/22/centos7%E4%B8%8Bservice(systemctl)%E7%9A%84%E9%85%8D%E7%BD%AE/</guid>
        
        <category>学习</category>
        
        <category>centos7</category>
        
        
      </item>
    
      <item>
        <title>docker集群管理技术--swarm</title>
        <description>&lt;h4 id=&quot;swarm介绍&quot;&gt;swarm介绍&lt;/h4&gt;
&lt;p&gt;swarm是用来部署服务的docker Engine集群。&lt;/p&gt;
&lt;h4 id=&quot;swarm&quot;&gt;swarm&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;创建一个swarm
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;docker swarm init --advertise-addr 192.179.177.11
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;查看swarm状态
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;docker info
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;第一步执行后会生成加入新节点的swarm命令，执行命令后加入的新节点作为manager或worker&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;docker node ls&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;加入节点命令
&lt;code class=&quot;highlighter-rouge&quot;&gt;docker swarm join --token 192.168,177.11:2377&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;查询添加节点的命令
&lt;code class=&quot;highlighter-rouge&quot;&gt;docker swarm join-token worker&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;docker node ls&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;服务service&quot;&gt;服务service&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;部署服务
&lt;code class=&quot;highlighter-rouge&quot;&gt;docker service create --replicas 3 | --name hello -p 80:80 nginx&lt;/code&gt;  —&amp;gt; 启动一个副本数为3的nginx服务
&lt;code class=&quot;highlighter-rouge&quot;&gt;docker service ls&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;查询服务的详细信息
&lt;code class=&quot;highlighter-rouge&quot;&gt;docker service inspect --pretty hello&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;docker service ps hello&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;扩容缩容
&lt;code class=&quot;highlighter-rouge&quot;&gt;docker service scale hello=5&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;删除服务
&lt;code class=&quot;highlighter-rouge&quot;&gt;docker service rm hello&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;滚动更新
&lt;code class=&quot;highlighter-rouge&quot;&gt;docker service create --replicas 3 --name redis --update-deloy 10s redis:3.0.6&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;docker service update --image redis:3.0.7 redis&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;下线节点
&lt;code class=&quot;highlighter-rouge&quot;&gt;docker node update --availability drain worker1&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;上线节点
&lt;code class=&quot;highlighter-rouge&quot;&gt;docker node update --availability active worker1&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;发布服务器端口
-publish 80：80
TCP -p 53:53/tcp
UDP -p 53:53/udp&lt;/li&gt;
  &lt;li&gt;升级或降级节点
&lt;code class=&quot;highlighter-rouge&quot;&gt;docker node promote node-2 w-&amp;gt;m&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;docker node demote node-12&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 21 Feb 2019 04:30:00 +0800</pubDate>
        <link>http://localhost:4000/2019/02/21/docker%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF-swarm/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/02/21/docker%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF-swarm/</guid>
        
        <category>学习</category>
        
        <category>docker</category>
        
        
      </item>
    
      <item>
        <title>MongoDB副本集搭建</title>
        <description>&lt;h4 id=&quot;副本集介绍&quot;&gt;副本集介绍&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;MongoDB 副本集（Replica Set）是有自动故障恢复功能的主从集群，有一个Primary节点和一个或多个Secondary节点组成。类似于MySQL的MMM架构。&lt;/li&gt;
  &lt;li&gt;副本集中数据同步过程：&lt;br /&gt;
  Primary节点写入数据，Secondary通过读取Primary的oplog得到复制信息，开始复制数据并且将复制信息写入到自己的oplog。如果某个操作失败，则备份节点停止从当前数据源复制数据。如果某个备份节点由于某些原因挂掉了，当重新启动后，就会自动从oplog的最后一个操作开始同步，同步完成后，将信息写入自己的oplog，由于复制操作是先复制数据，复制完成后再写入oplog，有可能相同的操作会同步两份，不过MongoDB在设计之初就考虑到这个问题，将oplog的同一个操作执行多次，与执行一次的效果是一样的。&lt;br /&gt;
简单的说就是：&lt;br /&gt;
当Primary节点完成数据操作后，Secondary会做出一系列的动作保证数据的同步：&lt;br /&gt;
1：检查自己local库的oplog.rs集合找出最近的时间戳。&lt;br /&gt;
2：检查Primary节点local库oplog.rs集合，找出大于此时间戳的记录。&lt;br /&gt;
3：将找到的记录插入到自己的oplog.rs集合中，并执行这些操作。&lt;br /&gt;
  副本集的同步和主从同步一样，都是异步同步的过程，不同的是副本集有个自动故障转移的功能。其原理是：slave端从primary端获取日志，然后在自己身上完全顺序的执行日志所记录的各种操作（该日志是不记录查询操作的），这个日志就是local数据 库中的oplog.rs表，默认在64位机器上这个表是比较大的，占磁盘大小的5%，oplog.rs的大小可以在启动参数中设 定：–oplogSize 1000,单位是M。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;副本集搭建&quot;&gt;副本集搭建&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;配置文件
&lt;code class=&quot;highlighter-rouge&quot;&gt;27017.config&lt;/code&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;dbpath = /data/mongo/db/27017
logpath = /data/mongo/log/27107.log
pidfilepath = /data/mongo/db/27017/27017.pid
replSet = mongo_sep          ---&amp;gt;  副本集名称
bind_ip = task               ---&amp;gt;  绑定服务ip
port = 27017                 ---&amp;gt;  服务占有端口
oplogSize = 30720            ---&amp;gt; 设置oplog大小
logappend = true             ---&amp;gt; 追加日志
fork = true                  ---&amp;gt; 以守护进程运行
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;启动mongod服务&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;./bin/mongod -f ./conf/27017.config &amp;amp;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;查看mongo状态
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;./mongo 192.168.177.11:27017
use admin
rs.status();
conf = {_id : 'mongo_sep', members: [{_id: 0, host: 'task:27017', priority: 10}, {_id : 1, host: 'task:28017', priority: 1}, {_id : 2, host: 'task:29017', arbiterOnly : true}]};
rs.initiate(conf);
rs.reconfig(conf);  若修改配置的话
rs.reconfig(conf, {'force': true})  强行修改配置
rs.status();  查看副本集是否成功
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;注意，配置文件需要三份，用于分别启动三个不同的mongod服务，端口分别为27017，28017，29017。&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 21 Feb 2019 04:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/02/21/MongoDB%E5%89%AF%E6%9C%AC%E9%9B%86%E6%90%AD%E5%BB%BA/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/02/21/MongoDB%E5%89%AF%E6%9C%AC%E9%9B%86%E6%90%AD%E5%BB%BA/</guid>
        
        <category>学习</category>
        
        <category>centos7</category>
        
        <category>MongoDB</category>
        
        
      </item>
    
      <item>
        <title>SSH免密码登录配置</title>
        <description>&lt;h4 id=&quot;ssh介绍&quot;&gt;SSH介绍&lt;/h4&gt;
&lt;p&gt;SSH是建立在应用层和传输层基础上的安全协议，其目的是为了远程登录会话和其他网络服务提供安全性的保障。
SSH密钥可实现无密码登录&lt;/p&gt;
&lt;h4 id=&quot;ssh无密码配置&quot;&gt;SSH无密码配置&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;检查是否生成过SSH密钥
切换到.ssh目录，&lt;code class=&quot;highlighter-rouge&quot;&gt;cd ~/.ssh&lt;/code&gt;
如果存在则表示已生成ssh密钥&lt;/li&gt;
  &lt;li&gt;使用ssh-keygen生成ssh密钥
&lt;code class=&quot;highlighter-rouge&quot;&gt;ssh-heygen -t rsa | dsa&lt;/code&gt;
生成ssh密钥之后，可以在～/.ssh目录下查看相关文件，一般ssh密钥包含id_rsa和id_rsa.pub两个文件，分别表示生成的密钥和公钥。&lt;/li&gt;
  &lt;li&gt;将.pub文件复制到另一台机器的.ssh目录下，并执行下面命令：
&lt;code class=&quot;highlighter-rouge&quot;&gt;cat id_rsa.pub &amp;gt;&amp;gt; ~/.ssh/authorized_keys&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;此时，私钥服务器可无密码登录公钥服务器，直接使用&lt;code class=&quot;highlighter-rouge&quot;&gt;ssh 192.168.177.11&lt;/code&gt;就可远程登录该服务器。
    &lt;h4 id=&quot;双向免密码登录配置&quot;&gt;双向免密码登录配置&lt;/h4&gt;
    &lt;p&gt;在A、B两台服务器都执行&lt;code class=&quot;highlighter-rouge&quot;&gt;ssh-heygen -t rsa&lt;/code&gt;命令，并将生成的公钥文件都发到对方的～/.ssh目录下，接着执行&lt;code class=&quot;highlighter-rouge&quot;&gt;cat id_rsa.pub &amp;gt;&amp;gt; ~/.ssh/authorized_keys&lt;/code&gt;即可实现双向免密码登录。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 21 Feb 2019 01:20:00 +0800</pubDate>
        <link>http://localhost:4000/2019/02/21/SSH%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E9%85%8D%E7%BD%AE/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/02/21/SSH%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E9%85%8D%E7%BD%AE/</guid>
        
        <category>学习</category>
        
        <category>centos7</category>
        
        
      </item>
    
      <item>
        <title>Django命令汇总</title>
        <description>&lt;ol&gt;
  &lt;li&gt;创建django工程&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;django-admin startproject demo&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;创建django app&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;django-admin startapp test&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;创建数据库表 &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;python manage.py makemigrations&lt;/code&gt;        —-&amp;gt; 创建更改的文件&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;python manage.py migrate&lt;/code&gt;               —-&amp;gt; 将改变应用到数据库&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;python manage.py syncdb&lt;/code&gt;                —-&amp;gt;旧版本使用&lt;/li&gt;
  &lt;li&gt;运行django服务&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;python manage.py runserver 0.0.0.0:8000&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;清空数据库&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;python manage.py flush&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;创建超级管理员&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;python manage.py createsuperuser&lt;/code&gt;&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;python manage.py changepassword username&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;导入数据，导出数据&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;python manage.py dumpdata appname &amp;gt; appname.json&lt;/code&gt;&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;python manage.py loaddata appname.json&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;进入shell&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;python manage.py shell&lt;/code&gt;&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;python manage.py dbshell&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 21 Feb 2019 01:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/02/21/Django%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/02/21/Django%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/</guid>
        
        <category>学习</category>
        
        <category>django</category>
        
        <category>python</category>
        
        
      </item>
    
      <item>
        <title>centos7安装mamcached</title>
        <description>&lt;h4 id=&quot;memcached介绍&quot;&gt;memcached介绍&lt;/h4&gt;
&lt;p&gt;memcached是一个高性能的分布式的内存对象缓存系统，原理是将数据调到内存中，然后从内存中读取，从而大大提高了读取速度。（用在动态应用中减少数据库负载，提高访问速度），数据只存储在内存中，不进行持久化。&lt;br /&gt;
&lt;strong&gt;分布式计算是将N颗cpu组装成一颗。&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;分布式慢速存储是将N个硬盘组成一个大硬盘。&lt;/strong&gt; &lt;br /&gt;
&lt;strong&gt;memcached是将N个内存组装成一个大内存。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;memcached安装&quot;&gt;memcached安装&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;yum安装
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;yum install libevent libevent-devel
yum install memcached
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;源代码安装
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;wget http://memcached.org/latest     -----&amp;gt;   下载
tar -zxvf memcached-1.x.tar.gz       -----&amp;gt;   解压
cd memcached-1.x
./configure  --prefix=/usr/local/memcached   ----&amp;gt;   配置
make &amp;amp;&amp;amp; make test                 -----&amp;gt;     编译
make install                      -----&amp;gt;     安装
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;memcached运行&quot;&gt;memcached运行&lt;/h4&gt;
&lt;p&gt;进入&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/bin/memcached&lt;/code&gt;目录&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;前台服务启动：&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;./memcached -p 11211 -m 64m -w&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;后台服务启动：
&lt;code class=&quot;highlighter-rouge&quot;&gt;./memcached -p 11211 -m 64m -d&lt;/code&gt;&lt;br /&gt;
或&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;./memcached -d -m 64m -u root -l 192.168.177.11 -p 11211 -c 256 -P /tmp/memcached.pid&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;启动参数详解：&lt;br /&gt;
-d : 启动一个进程&lt;br /&gt;
-m : 分配的内存数量&lt;br /&gt;
-u : 用户&lt;br /&gt;
-l : ip地址&lt;br /&gt;
-p : 监听的端口&lt;br /&gt;
-c : 最大运行的并发数&lt;br /&gt;
-P : 设置保存memcached的pid文件
    &lt;h4 id=&quot;python访问memcached&quot;&gt;python访问memcached&lt;/h4&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pip install pymemchched&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;from pymemcached.client.base import Client
mc = Client('192.168.177.11', 11211)
mc.set('name', 'yan')
mc.get('name')

mc.set_multi({'k1': 'v1', 'k2': 'v2'})
mc.get_multi(['k1', 'k2'])
mc.get_many(['k1', 'k2'])
mc.delete_multi(['k1', 'k2'])

mc.add('name', 'li')
mc.replace('name', 'w')
mc.delete('name')

mc.append('name', 'hello')
mc.prepend('name', 'hi')

mc.incr('age', 1)
mc.decr('age', 10)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Thu, 21 Feb 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/02/21/centos7%E5%AE%89%E8%A3%85memcahed/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/02/21/centos7%E5%AE%89%E8%A3%85memcahed/</guid>
        
        <category>学习</category>
        
        <category>centos7</category>
        
        <category>python</category>
        
        <category>mamcached</category>
        
        
      </item>
    
  </channel>
</rss>
